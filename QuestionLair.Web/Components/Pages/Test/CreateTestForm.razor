@using FluentValidation

<MudForm Model="@model" @ref="@form" Validation="@(loginRequestValidator.ValidateValue)" ValidationDelay="0">
    <MudCardContent>
        <MudTextField @bind-Value="model.Email" For="@(() => model.Email)" Immediate="true" Label="Title" />

    </MudCardContent>
</MudForm>

@code {
    [Parameter] public List<Material> Materials { get; set; }
    private string GetMultiSelectionText(List<string> selectedValues)
    {
        return $"{selectedValues.Count} feline{(selectedValues.Count > 1 ? "s have" : " has")} been selected";
    }
    LoginRequestFluentValidator loginRequestValidator = new LoginRequestFluentValidator();
    LoginRequestDTO model = new LoginRequestDTO();
    MudForm form;

    private async Task Submit()
    {
        await form.Validate();

        if (form.IsValid)
        {
        }
    }

    public class LoginRequestFluentValidator : AbstractValidator<LoginRequestDTO>
    {
        public LoginRequestFluentValidator()
        {
            RuleFor(x => x.Email)
            .Cascade(CascadeMode.Stop)
            .NotEmpty()
            .EmailAddress();

            RuleFor(x => x.Password)
            .NotEmpty()
            .Length(1, 100);
        }
        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<LoginRequestDTO>.CreateWithOptions((LoginRequestDTO)model, x =>
    x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }
}